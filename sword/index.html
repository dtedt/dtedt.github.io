<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sword Parry</title>
    <style>
        /* [Previous CSS remains exactly the same] */
    </style>
</head>
<body>
    <!-- [Previous HTML remains exactly the same] -->

    <script>
        // [Previous variable declarations remain the same until enemyTypes]

        // Enemy types - added feintChance
        const enemyTypes = [
            { color: '#ff5555', speed: 2, radius: 20, attackCooldown: 1000, feintChance: 0.3 }, // Slow
            { color: '#ff9999', speed: 3, radius: 15, attackCooldown: 800, feintChance: 0.5 },  // Medium
            { color: '#ffcccc', speed: 4, radius: 12, attackCooldown: 600, feintChance: 0.7 }   // Fast
        ];

        // [Previous functions remain the same until createEnemy]

        function createEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const type = Math.floor(Math.random() * enemyTypes.length);
            const spawnDistance = Math.max(canvas.width, canvas.height) * 0.7;
            const x = player.x + Math.cos(angle) * spawnDistance;
            const y = player.y + Math.sin(angle) * spawnDistance;
            
            enemies.push({
                x: x,
                y: y,
                angle: angle,
                speed: enemyTypes[type].speed,
                radius: enemyTypes[type].radius,
                color: enemyTypes[type].color,
                attackCooldown: enemyTypes[type].attackCooldown,
                feintChance: enemyTypes[type].feintChance,
                state: 'approaching',
                parryTime: 0,
                hitPlayer: false,
                recoveryTimer: 0,
                originalSpeed: enemyTypes[type].speed,
                orbitAngle: angle,
                orbitRadius: player.parryRadius * 1.5,
                circleTimer: 0,
                circleDuration: randomBetween(5000, 12000),
                windupTimer: 0,
                willFeint: Math.random() < enemyTypes[type].feintChance,
                feinted: false
            });
        }

        // [Previous update function remains the same until windup state]

        else if (enemy.state === 'windup') {
            enemy.windupTimer -= deltaTime;
            
            if (enemy.windupTimer <= 0) {
                if (enemy.willFeint && !enemy.feinted) {
                    // Perform feint
                    enemy.state = 'feinting';
                    enemy.feinted = true;
                    enemy.windupTimer = 300; // Feint duration
                    enemy.speed = enemy.originalSpeed * 0.5;
                    
                    // After feinting, circle again before real attack
                    enemy.circleTimer = 0;
                    enemy.circleDuration = randomBetween(2000, 5000);
                } else {
                    // Real attack
                    enemy.state = 'attacking';
                    enemy.speed = enemy.originalSpeed * 3;
                    enemy.hitPlayer = false;
                    enemy.parryTime = timestamp + 50;
                }
            }
        }
        else if (enemy.state === 'feinting') {
            enemy.windupTimer -= deltaTime;
            
            // Move away slightly during feint
            enemy.x += Math.cos(enemy.angle) * enemy.speed;
            enemy.y += Math.sin(enemy.angle) * enemy.speed;
            
            if (enemy.windupTimer <= 0) {
                enemy.state = 'circling';
            }
        }

        // [Previous draw function remains the same until enemy drawing]

        // In the draw function, add feinting state visualization:
        else if (enemy.state === 'feinting') {
            const flash = Math.sin(Date.now() / 100) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, ${255 * flash}, 100, 1)`;
            
            // Draw feint indicator
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius * 1.2, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 100, 100, ${flash})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // [Rest of the code remains exactly the same]
    </script>
</body>
</html>